<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!--Description-->
    
        <meta name="description" content="Java 函数式编程 博客">
    

    <!--Author-->
    
        <meta name="author" content="Matrix">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Java8函数式编程-函数式备忘录模式优化递归">
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Matrix World">

    <!--Page Cover-->
    
        <meta property="og:image" content="undefined">
    

    <!-- Title -->
    
    <title>Java8函数式编程-函数式备忘录模式优化递归 - Matrix World</title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/sass/main.css">

    <!--[if lt IE 8]>
        <script src="/js/ie/html5shiv.js"></script>
    <![endif]-->

    <!--[if lt IE 8]>
        <link rel="stylesheet" href="/sass/ie8.css">
    <![endif]-->

    <!--[if lt IE 9]>
        <link rel="stylesheet" href="/sass/ie9.css">
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.css" type="text/css" rel="stylesheet">

    <!-- Google Analytics -->
    
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-136106299-1', 'auto');
        ga('send', 'pageview');

    </script>



</head>

<body>

    <div id="wrapper">

        <!-- Menu -->
        <!-- Header -->
<header id="header">
    <div class="inner">

        <!-- Logo -->
        <a href="/" class="logo">
            <span class="symbol"><img src="/img/logo.svg" alt></span><span class="title">Matrix World</span>
        </a>

        <!-- Nav -->
        <nav>
            <ul>
                <li><a href="#menu">Menu</a></li>
            </ul>
        </nav>

    </div>
</header>

<!-- Menu -->
<nav id="menu">
    <h2>Menu</h2>
    <ul>
        
            <li>
                <a href="/">Home</a>
            </li>
        
            <li>
                <a href="/archives">Archives</a>
            </li>
        
            <li>
                <a href="/about.html">About</a>
            </li>
        
    </ul>
</nav>


        <div id="main">
            <div class="inner">

                <!-- Main Content -->
                

    <h1>Java8函数式编程-函数式备忘录模式优化递归</h1>


    <span class="image main"><img src="/img/18-03-12-01.jpg" alt></span>


<!-- Gallery -->


<!-- Content -->
<div class="toc">

<!-- toc -->
<ul>
<li><a href="#qian-yan">前言</a></li>
<li><a href="#hui-gu">回顾</a><ul>
<li><a href="#di-gui-qiu-jie">递归求解</a></li>
<li><a href="#wei-di-gui-qiu-jie">尾递归求解</a></li>
<li><a href="#die-dai-qiu-jie">迭代求解</a></li>
</ul>
</li>
<li><a href="#fen-xi-di-gui-xiao-lu-di-xia-de-yuan-yin">分析递归效率低下的原因</a></li>
<li><a href="#shi-yong-bei-wang-lu-mo-shi-cun-chu-jie-guo">使用备忘录模式存储结果</a><ul>
<li><a href="#before-java8">Before Java8</a></li>
<li><a href="#in-java8">In Java8</a></li>
</ul>
</li>
<li><a href="#shi-yong-lambda-feng-zhuang-shang-shu-bei-wang-lu-mo-shi-you-hua-di-gui">使用lambda封装上述备忘录模式优化递归</a><ul>
<li><a href="#qian-ming-she-ji">签名设计</a></li>
<li><a href="#ju-ti-shi-xian">具体实现</a></li>
<li><a href="#zui-zhong-dai-ma">最终代码</a></li>
<li><a href="#yun-yong">运用</a><ul>
<li><a href="#han-nuo-ta-di-gui-wen-ti">汉诺塔递归问题</a></li>
<li><a href="#gan-qie-ge-wen-ti">杆切割问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#zong-jie">总结</a></li>
</ul>
<!-- tocstop -->
</div>

<h1><span id="qian-yan">前言</span></h1><p>在上一篇<a href="https://xhyrzldf.github.io/2019/03/12/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E5%B0%BE%E9%80%92%E5%BD%92/">使用lambda实现Java的尾递归</a>中，我们利用了函数的懒加载机制实现了栈帧的复用，成功的实现了Java版本的尾递归，然而尾递归的使用有一个重要的条件就是递归表达式必须是在函数的尾部，但是在很多实际问题中，例如分治，动态规划等问题的解决思路虽然是使用递归来解决，但往往那些解决方式要转换成尾递归花费很多精力，这也违背了递归是用来简洁地解决问题这个初衷了，本篇介绍的是使用备忘录模式来优化这些递归，并且使用lambda进行封装，以备复用。</p>
<h1><span id="hui-gu">回顾</span></h1><p>为了回顾上一章节，同时用本章的例子作对比，我们这里使用经典的<code>斐波那契数列</code>求解问题作为例子来讲解。<br>斐波那契数列表示这样的一组数 1,1,2,3,5,8,13…. 其表现形式为数列的第一个和第二个数为1,其余的数都是它前两位数的和，用公式表示为</p>
<script type="math/tex; mode=display">a_n =\left\{
\begin{aligned}
1, n <= 1\\
a_{n-1} + a_{n-2} , n > 1
\end{aligned}
,n\in N
\right.</script><h2><span id="di-gui-qiu-jie">递归求解</span></h2><p>这里我们依据上面的数列公式直接使用递归解法求解该问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归求解斐波那契数列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 第n个斐波那数列契数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 斐波那契数列的第n个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fibonacciRecursion</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fibonacciRecursion(n - <span class="number">1</span>) + fibonacciRecursion(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归测试斐波那契数列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFibonacciRec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    System.out.println(fibonacciRecursion(<span class="number">47</span>));</span><br><span class="line">    System.out.printf(<span class="string">"cost %.2f ms %n"</span>, (System.nanoTime() - start) / Math.pow(<span class="number">10</span>, <span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们测试当n等于47的时候,所要花费的时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4807526976</span></span><br><span class="line">cost <span class="number">13739.30</span> ms</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以看出,递归的写法虽然简洁,但是消耗的时间是成指数级的。</p>
<h2><span id="wei-di-gui-qiu-jie">尾递归求解</span></h2><p>这里回顾上一章内容,使用尾递归求解,具体这里的尾递归接口的实现这里就不贴出来了(<a href="https://xhyrzldf.github.io/2019/03/12/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E5%B0%BE%E9%80%92%E5%BD%92/">点击这里查看</a>)，下面是尾递归的具体调用代码,增加两个变量分别保存$a_{n-2}$与$a_{n-1}$ 在下面的形参对应的分别是<code>accPrev</code>与<code>accNext</code>,尾递归是自底向上的,你可以理解成迭代的方式，每次调用递归将$a_{n-1}$赋值给$a_{n-2}$,将$a_{n-1} + a_{n-2}$ 赋值给 $a_{n-1}$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾递归求解斐波那契数列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> accPrev 第n-1个斐波那契数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> accNext 第n个斐波那契数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 第n个斐波那契数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含了一系列斐波那契的完整计算过程,调用invoke方法启动计算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TailRecursion&lt;Long&gt; <span class="title">fibonacciRecursionTail</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> accPrev,<span class="keyword">final</span> <span class="keyword">long</span> accNext, <span class="keyword">final</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> TailInvoke.done(accNext);</span><br><span class="line">    <span class="keyword">return</span> TailInvoke.call(() -&gt; fibonacciRecursionTail(accNext, accPrev + accNext, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾递归测试斐波那契数列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFibonacciTailRec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    System.out.println(fibonacciRecursionTail(<span class="number">1</span>,<span class="number">1</span>,<span class="number">47</span>).invoke());</span><br><span class="line">    System.out.printf(<span class="string">"cost %.2f ms %n"</span>, (System.nanoTime() - start) / Math.pow(<span class="number">10</span>, <span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样测试当n等于47的时候,所要花费的时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4660046610375530309</span></span><br><span class="line">cost <span class="number">97.67</span> ms</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以看出花费的时间是线性级别的，但是因为这里的尾递归是手动封装的，所以接口类的建立以及lambda表达式的调用等一些基本开销占用了大部分的时间，但是这是常数级别的时间，计算过程本身几乎不花费什么时间,所以性能也是十分好的。</p>
<h2><span id="die-dai-qiu-jie">迭代求解</span></h2><p>尾递归在优化之后在计算过程上就变成了自底向上，因此也就是转变成了迭代的过程,这里大家配合迭代求解来理解尾递归求解应该会容易许多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 斐波那契的迭代解法,自底向上求解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 第n个斐波那契数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 第n个斐波那契数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fibonacciIter</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> prev = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> next = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> accumulate = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        accumulate = prev + next;</span><br><span class="line">        prev = next;</span><br><span class="line">        next = accumulate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> accumulate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代测试斐波那契数列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFibonacciIter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    System.out.println(fibonacciIter(<span class="number">47</span>));</span><br><span class="line">    System.out.printf(<span class="string">"cost %.2f ms %n"</span>, (System.nanoTime() - start) / Math.pow(<span class="number">10</span>, <span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样测试当n等于47的时候,所要花费的时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4660046610375530309</span><br><span class="line">cost 0.09 ms</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>这里只花费了0.09ms,其实迭代计算的时间和尾递归理论上应该是差不多的，但是上文也说到了，尾递归由于是自己的封装接口并且本身使用lambda也会有一定的开销,所以会造成一些性能上的差异。</p>
<h1><span id="fen-xi-di-gui-xiao-lu-di-xia-de-yuan-yin">分析递归效率低下的原因</span></h1><p>可以看到上面的三种解决方案,尾递归与迭代的效率是可以接受的，而递归虽然写起来最短，但是时间复杂度是指数级别的，完全不能够接受，那么这里就分析为什么第一种的递归如此之慢，而第二种与第三种就要快上很多。<br>第一种的解决思路是最直接的,假设我们要求解<code>f(5)</code>这个数,我们会将问题转化成<code>f(3) + f(4)</code>,接着再转化<br>成<code>f(1)+f(2)+f(2)+f(3)</code>…依次类推,如图所示</p>
<hr>
<p><img src="/img/fib.png" alt="image"></p>
<p>通过简单的观察可以发现,这里的<code>f(0)</code>,<code>f(1)</code>,<code>f(2)</code>等被重复计算了很多次,随着树的高度的提升,这样的重复计算会以指数级别的程度增长,这就是为什么第一种递归解法的效率为什么这么低下的原因。</p>
<p>那么我们来看看为什么尾递归与迭代的效率会这么高，前面也说到了，经过优化之后的尾递归与迭代的计算方式是自底向上的，同样以计算<code>f(5)</code>为例子,他们不是从<code>f(5)</code>开始往下计算,而是从前往后,先计算出<code>f(2)</code>然后根据<code>f(2)</code>计算出<code>(3)</code>再根据<code>f(2)与f(3)</code>计算出<code>(f4)</code>最终计算出<code>f(5)</code>，也就是说,自底向上的每一次计算都运用到了前面计算的结果，因此中间过程并没有重复的计算，所以效率很高。</p>
<p>经过上面的总结，我们得出了如果想要递归高效的进行，那么要解决的就是如何避免重复的计算,也就是要利用之前已经计算过的结果。</p>
<h1><span id="shi-yong-bei-wang-lu-mo-shi-cun-chu-jie-guo">使用备忘录模式存储结果</span></h1><p>经过上面的分析，我们得到了要想解决效率问题，就必要存储并且重复利用之前的计算结果，因此显而易见的我们这里使用散列表这个数据结构来存储这些信息。<br>我们将已经计算过的结果存储在散列表里，下一次遇到需要计算这个问题的时候直接取出来，如果散列表里没有这样的数据，我们才进行计算并且存储计算结果，把他想象成计算结果的缓存来理解。</p>
<h2><span id="before-java8">Before Java8</span></h2><p>为了保证线程安全我们使用<code>synchronized</code>关键字与<code>double-check</code>来保证,代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, Long&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用备忘录模式来利用重复计算结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 第n个斐波那契数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 第n个斐波那契数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fibonacciMemo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">  Long exceptedNum = cache.get(n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exceptedNum == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">      exceptedNum = cache.get(n);</span><br><span class="line">      <span class="keyword">if</span> (exceptedNum == <span class="keyword">null</span>) &#123;</span><br><span class="line">        exceptedNum = fibRecurOpt(n - <span class="number">1</span>) + fibRecurOpt(n - <span class="number">2</span>);</span><br><span class="line">        cache.put(n, exceptedNum);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> exceptedNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="in-java8">In Java8</span></h2><p>这样的代码虽然可以达到效率的优化，但是不管是复用性还是可读性基本上为0，因此这里我们使用java8 Map结构新增的<code>computeIfAbsent</code>,该方法接受两个参数,一个key值,一个是function计算策略，从字面意思也可以明白,作用就是如果key值为空,那么就执行后面的function策略，因此使用<code>computeIfAbsent</code>后的优化代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, Long&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用computeIfAbsent来优化备忘录模式</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fibonacciMemoOpt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">return</span> cache.computeIfAbsent(n, key -&gt; fibRecurLambdaOpt(n - <span class="number">1</span>) + fibRecurLambdaOpt(n - <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样代码的可读性就高了不少，每次调用递归方法的时候直接返回cache里的计算结果,如果没有该计算结果,那么就执行后面一段计算过程来得到计算结果，下面进行时间的测试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试备忘录模式递归求解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFibonacciMemoOpt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    System.out.println(fibonacciMemoOpt(<span class="number">47</span>));</span><br><span class="line">    System.out.printf(<span class="string">"cost %.2f ms %n"</span>, (System.nanoTime() - start) / Math.pow(<span class="number">10</span>, <span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2971215073</span></span><br><span class="line">cost <span class="number">80.36</span> ms </span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>发现运行的时间已经大大的减少了,并且消耗时间和之前的尾递归几乎差不多。</p>
<p>到这一步,大部分工作已经完成了,递归代码也十分的简短高效，剩下的就是复用了，接下来我们对上述的分析过程进行抽象，将备忘录模式完全封装,这样以后需要使用类似的情况可以直接使用。</p>
<h1><span id="shi-yong-lambda-feng-zhuang-shang-shu-bei-wang-lu-mo-shi-you-hua-di-gui">使用lambda封装上述备忘录模式优化递归</span></h1><h2><span id="qian-ming-she-ji">签名设计</span></h2><p>其实看一看标题，感觉似乎一直到现在才讲到重点,其实我也考虑过直接跳过上面所有的介绍写这里，但是我觉得如果这么写的话，给人的感觉会太直接，上一篇尾递归的封装我就有这样的感觉，感觉似乎太直接了，没有具体的分析过程就直接封装，感觉可读性不是很高，所以这一篇花了比较长的篇幅来一步一步讲解整个的过程，希望能让大家更容易的去理解。</p>
<p>首先我们要考虑设计的封装需要几个参数，这里应该是两个，分别是 斐波那契的算法策略 与输入值，也就是说我们向这个备忘录方法传入一个斐波那契的算法策略function，以及一个输入值n,这个备忘录方法就应该返回正确的结果给我们，因此这个方法的签名初步构想应该是这样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, R&gt; <span class="function">R <span class="title">callMemo</span><span class="params">(<span class="keyword">final</span> Function&lt;T,R&gt; function, <span class="keyword">final</span> T input)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>T为输入值类型</li>
<li>R为返回值类型</li>
<li>function 为具体的计算策略，这这里的例子中，就是斐波那契的计算策略</li>
</ul>
<p>但这仅仅是初步构想，这里会碰到的一个问题就是，因为我们的策略是递归策略，因此必须要有一个方法名，而众所周知，lambda函数全部是匿名的，也就是说，直接单纯的使用lambda根本无法递归调用，因为lambda方法没有名字，怎么调用自己呢？ 那该怎么办呢？其实很简单，我们只需要再封装一层，也就是说将策略本身作为参数来传递，然后使用this调用即可，这里的思想其实就是利用了尾递归的思想，将每一次递归调用需要的策略本身作为参数来传递。</p>
<p>因此我们上面参数的function 要稍作修改,增加一个策略本身作为参数，因此function的类型应该是<code>BiFunction&lt;Function&lt;T,R&gt;,T,R&gt;</code> 仔细观察一下泛型里的类型,只是由原来的<code>&lt;T,R&gt;</code>在前面多了一个策略本身参数<code>Function&lt;T,R&gt;</code>，这样2个参数的组合我们使用BiFunction，因此最终的方法签名如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, R&gt; <span class="function">R <span class="title">callMemo</span><span class="params">(<span class="keyword">final</span> BiFunction&lt;Function&lt;T,R&gt;,T,R&gt; function, <span class="keyword">final</span> T input)</span></span></span><br></pre></td></tr></table></figure>
<p>知晓了方法签名与每一个参数的意思之后,完成最终的实现就十分容易了</p>
<h2><span id="ju-ti-shi-xian">具体实现</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 备忘录模式 函数封装</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> function 递归策略算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> input 输入值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 输出值类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; 返回值类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 将输入值输入递归策略算法，计算出的最终结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, R&gt; <span class="function">R <span class="title">callMemo</span><span class="params">(<span class="keyword">final</span> BiFunction&lt;Function&lt;T, R&gt;, T, R&gt; function, <span class="keyword">final</span> T input)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Function&lt;T, R&gt; memo = <span class="keyword">new</span> Function&lt;T, R&gt;() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, R&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> R <span class="title">apply</span><span class="params">(<span class="keyword">final</span> T input)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cache.computeIfAbsent(input, key -&gt; function.apply(<span class="keyword">this</span>, key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> memo.apply(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为了保证这个散列表Map每次只为一个递归策略服务，我们在方法内部实例化一个实现function的类，并将Map存入其中，这样就能够保证Map服务的唯一性，在apply方法中<code>cache.computeIfAbsent(input, key -&gt; function.apply(this, key))</code>这一句就是为什么方法的签名要多一个function的参数原因,因为策略是递归策略，lambda函数没有名字，所以必须显示的将他存入参数中，这样才能完成递归调用，这里使用this将自己本身作为策略传递下去。</p>
<p>此时我们要调用的话，只需要将完成这个策略即可,调用代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用同一封装的备忘录模式 执行斐波那契策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 第n个斐波那契数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 第n个斐波那契数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fibonacciMemo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callMemo((fib, number) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">0</span> || number == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">return</span> fib.apply(number -<span class="number">1</span> ) + fib.apply(number-<span class="number">2</span>);</span><br><span class="line">    &#125;, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="zui-zhong-dai-ma">最终代码</span></h2><p>这样调用的可读性可能有点差,因此我们将第一个参数抽离出来,使用方法引用来调用,最终代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factorial</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用统一封装的备忘录模式 对外开放的方法,在内部执行具体的斐波那契策略 &#123;<span class="doctag">@link</span> #fibonacciCallMemo(Function, Integer)&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 第n个斐波那契数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 第n个斐波那契数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fibonacciMemo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> callMemo(Factorial::fibonacciCallMemo, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有方法,服务于&#123;<span class="doctag">@link</span> #fibonacciMemo(int)&#125; ,内部实现为斐波那契算法策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fib 斐波那契算法策略自身,用于递归调用, 在&#123;<span class="doctag">@link</span> #callMemo(BiFunction, Object)&#125; 中通过传入this来实例这个策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 第n个斐波那契数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 第n个斐波那契数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fibonacciCallMemo</span><span class="params">(Function&lt;Integer,Long&gt; fib,Integer n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fib.apply(n -<span class="number">1</span> ) + fib.apply(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备忘录模式 函数封装</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> function 递归策略算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input 输入值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 输出值类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt; 返回值类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 将输入值输入递归策略算法，计算出的最终结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, R&gt; <span class="function">R <span class="title">callMemo</span><span class="params">(<span class="keyword">final</span> BiFunction&lt;Function&lt;T, R&gt;, T, R&gt; function, <span class="keyword">final</span> T input)</span> </span>&#123;</span><br><span class="line">        Function&lt;T, R&gt; memo = <span class="keyword">new</span> Function&lt;T, R&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, R&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> R <span class="title">apply</span><span class="params">(<span class="keyword">final</span> T input)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cache.computeIfAbsent(input, key -&gt; function.apply(<span class="keyword">this</span>, key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> memo.apply(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用<code>fibonacciMemo(47)</code>方法来计算时间,输出结果为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4807526976</span></span><br><span class="line">cost <span class="number">69.19</span> ms </span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>运转良好，并且复用性强，每次使用这个模式的时候并不需要编写额外的代码，也不需要考虑内部的Map的线程安全或者是策略独立。</p>
<h2><span id="yun-yong">运用</span></h2><p>这里我们是用来解决斐波那契数列递归问题，下面我们分别用于经典的分治算法-<a href="http://www.cnblogs.com/invoker-/p/7617472.html" target="_blank" rel="noopener">汉诺塔递归问题</a>与动态规划-<a href="http://www.geeksforgeeks.org/dynamic-programming-set-13-cutting-a-rod/" target="_blank" rel="noopener">分割杆问题</a>,篇幅有限,这两个问题我不作具体说明了,直接给出初始的递归解法代码,(具体的问题点击上面两个问题的蓝色链接即可)来看看该如何使用我们封装好的备忘录模式方法。</p>
<h3><span id="han-nuo-ta-di-gui-wen-ti">汉诺塔递归问题</span></h3><p>汉诺塔递归问题一般有2个,一个问最少要移动多少次,另一个一般是要给出具体的每一步的过程</p>
<ul>
<li>先看最少要移动多少次这个问题<br>递归代码如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countMovePlate</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> countMovePlate(n - <span class="number">1</span>) + <span class="number">1</span> +countMovePlate(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用我们的备忘录模式来优化解决如下(同样可以使用上文的方法引用抽离第一个参数,使得代码可读性更高)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countMovePlateMemo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callMemo((count, num) -&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;=<span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">return</span> count.apply(num) + <span class="number">1</span> + count.apply(num);</span><br><span class="line">    &#125;,n );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>再看具体的每一步的移动过程</li>
</ul>
<p>递归代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">movePlate</span><span class="params">(<span class="keyword">int</span> n, String from, String mid, String to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(from + <span class="string">" -&gt; "</span> + to);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    movePlate(n - <span class="number">1</span>, from, to, mid);</span><br><span class="line">    System.out.println(from + <span class="string">" -&gt; "</span> + to);</span><br><span class="line">    movePlate(n - <span class="number">1</span>, mid, from, to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用方法引用,由于哈诺塔具体移动的初始代码有4个参数,因此我们将参数存入数组中来处理,可以看到和原先的代码相比,只是增加了一个参数处理,就使用了备忘录模式,完全隐去了细节</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">movePlate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">movePlateMemo</span><span class="params">(<span class="keyword">int</span> n, String from, String mid, String to)</span></span>&#123;</span><br><span class="line">        Object[] params = &#123;n, from, mid, to&#125;;</span><br><span class="line">        <span class="keyword">return</span> callMemo(movePlate::movePlateCallMemo,params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">movePlateCallMemo</span><span class="params">(Function&lt;Object[],Boolean&gt; function,Object[] params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将数组里的参数初始化,这样不影响之前的代码</span></span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>) params[<span class="number">0</span>];</span><br><span class="line">        String from = (String) params[<span class="number">1</span>];</span><br><span class="line">        String mid = (String) params[<span class="number">2</span>];</span><br><span class="line">        String to = (String) params[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//原先的递归代码,没有差别,将递归调用转换成为function.apply()</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(from + <span class="string">" -&gt; "</span> + to);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        function.apply(<span class="keyword">new</span> Object[]&#123;n - <span class="number">1</span>, from, to, mid&#125;);</span><br><span class="line">        System.out.println(from + <span class="string">" -&gt; "</span> + to);</span><br><span class="line">        function.apply(<span class="keyword">new</span> Object[]&#123;n - <span class="number">1</span>, mid, from, to&#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试是否可行,输入参数3，A,B,C,发现运转良好</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; c</span><br><span class="line">A -&gt; B</span><br><span class="line">c -&gt; B</span><br><span class="line">A -&gt; c</span><br><span class="line">B -&gt; A</span><br><span class="line">B -&gt; c</span><br><span class="line">A -&gt; c</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3><span id="gan-qie-ge-wen-ti">杆切割问题</span></h3><p>初始递归代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> profit = (length &lt;= prices.size()) ? prices.get(length - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> priceWhenCut = maxProfit(i) + maxProfit(length - i);</span><br><span class="line">        <span class="keyword">if</span>(profit &lt; priceWhenCut) profit = priceWhenCut;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的简单更改一下递归处的调用就可以更改为备忘录的优化,这里为了节省代码不使用方法引用,直接实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> rodLenth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callMemo(</span><br><span class="line">        (func,length) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> profit = (length &lt;= prices.size()) ? prices.get(length - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> priceWhenCut = func.apply(i) + func.apply(length - i);</span><br><span class="line">            <span class="keyword">if</span>(profit &lt; priceWhenCut) profit = priceWhenCut;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">        &#125;, rodLenth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="zong-jie">总结</span></h1><p>不得不承认，这一章的内容是比较难的，尤其是在对递归方法的签名设计上，要理解这一切需要有一定的函数编程设计的理解,所以我用了很长的篇幅来一步步讲述为什么要这么封装，前面的设计为什么要这么设计，以及最后选了斐波那契,汉诺塔，杆切割的原始递归代码来优化成备忘录模式，习惯了面向对象的设计在碰到函数式的方式设计的时候确实容易一头包，不过没有人生下来就会这一切，因此我在这里想说的是，practise makes perfect，熟能生巧，希望每个人都能成为自己心目中的大师 :)</p>


<!-- Tags -->



<div class="tags">
    <a href="/tags/Java/" class="button small">Java</a> <a href="/tags/函数式编程/" class="button small">函数式编程</a>
</div>



<!-- Comments -->
<!--PC版-->
<div id="SOHUCS"></div>
<script charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/changyan.js"></script>
<script type="text/javascript">
window.changyan.api.config({
appid: 'cyu87j9If',
conf: 'prod_7793045929c2d4705abb93f9559a3431'
});
</script>
<!-- <div>
    


</div> -->



            </div>
        </div>

        <!-- Footer -->
<footer id="footer">
    <div class="inner">
        <section>
            <h2>About</h2>
            <div>
                
            </div>
        </section>
        <section>
            <h2>Follow</h2>
            <ul class="icons">
                
                    <li><a href="https://twitter.com/?lang=en" class="icon style2 fa-twitter" target="_blank"><span class="label">Twitter</span></a></li>
                
                
                    <li><a href="https://www.facebook.com/" class="icon style2 fa-facebook" target="_blank"><span class="label">Facebook</span></a></li>
                
                
                
                
                    <li><a href="https://github.com/xhyrzldf" class="icon style2 fa-github" target="_blank"><span class="label">GitHub</span></a></li>
                
                
                    <li><a href="https://plus.google.com/" class="icon style2 fa-google-plus" target="_blank"><span class="label">Google+</span></a></li>
                
                
                
                
                
            </ul>
        </section>
        <ul class="copyright">
            <li>&copy; Untitled. All rights reserved</li>
            <li>Design: <a href="http://html5up.net" target="_blank">HTML5 UP</a></li>
            <li>Hexo: <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></li>
        </ul>
    </div>
</footer>
    </div>

    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- skel -->
<script src="/js/skel.min.js"></script>

<!-- Custom Code -->
<script src="/js/util.js"></script>

<!--[if lte IE 8]>
<script src="/js/ie/respond.min.js"></script>
<![endif]-->

<!-- Custom Code -->
<script src="/js/main.js"></script>

<!-- Gallery -->
<script src="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>